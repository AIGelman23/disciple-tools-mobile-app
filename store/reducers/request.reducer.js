import * as actions from '../actions/request.actions';

const initialState = {
  queue: [],
  currentAction: {},
};

export function generateLocalID() {
  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (c) => {
    /* eslint-disable */
    const r = Math.random() * 16 | 0;
    const v = c === 'x' ? r : ((r && 0x3) | 0x8);
    /* eslint-enable */
    return v.toString(16);
  });
}

export default function requestReducer(state = initialState, action) {
  let newState = {
    ...state,
    currentAction: {},
  };
  let queue = newState.queue.slice(0); // clone array before modifying it
  const actionToModify = action.payload;
  switch (action.type) {
    case actions.REQUEST:
      // Queue all requests
      if (actionToModify.data.method === 'POST' && actionToModify.action.includes('SAVE')) {
        // Map only POST requests
        let jsonBody = JSON.parse(actionToModify.data.body);
        if (Object.prototype.hasOwnProperty.call(action.payload, 'isConnected')) {
          const jsonBodyId = jsonBody.ID;
          const { isConnected } = actionToModify;
          delete actionToModify.isConnected;
          if (isConnected) {
            delete jsonBody.ID;
            // Phone its in ONLINE mode
            if (jsonBodyId) {
              /* eslint-disable */
              if (isNaN(jsonBodyId)) {
                /* eslint-enable */
                // ONLINE POST (Existing autogenerated ID) Merge request in queue and process it
                // If entity has ID, search it in queue, if exist, merge it
                const requestIndex = queue.findIndex(request => request.data.method === 'POST' && JSON.parse(request.data.body).ID && JSON.parse(request.data.body).ID === jsonBodyId);
                if (requestIndex > -1) {
                  // Remove all autogeneratedIDs in json
                  Object.keys(jsonBody).forEach((key) => {
                    const value = jsonBody[key];
                    const valueType = Object.prototype.toString.call(value);
                    if (valueType === '[object Array]' || Object.prototype.hasOwnProperty.call(value, 'values')) {
                      let collectionHasValues; let
                        mappedValue;
                      // "contact_" like field
                      if (valueType === '[object Array]') {
                        collectionHasValues = (
                          value.length > 0
                          && Object.prototype.toString.call(value[0]) === '[object Object]'
                          && Object.prototype.hasOwnProperty.call(value[0], 'value')
                        );
                        mappedValue = value;
                      } else if (Object.prototype.hasOwnProperty.call(value, 'values')) {
                        // { value: '' } array field
                        collectionHasValues = (
                          value.values.length > 0
                          && Object.prototype.toString.call(value.values[0]) === '[object Object]'
                          && Object.prototype.hasOwnProperty.call(value.values[0], 'value')
                        );
                        mappedValue = value.values;
                      }
                      if (collectionHasValues) {
                        // Remove AutogeneratedID of objects
                        mappedValue = mappedValue.map((object) => {
                          const copyObject = { ...object };
                          delete copyObject.key;
                          return copyObject;
                        });
                        if (valueType === '[object Array]') {
                          jsonBody = {
                            ...jsonBody,
                            [key]: mappedValue,
                          };
                        } else if (Object.prototype.hasOwnProperty.call(value, 'values')) {
                          jsonBody = {
                            ...jsonBody,
                            [key]: {
                              values: mappedValue,
                            },
                          };
                        }
                      }
                    } else {
                      jsonBody = {
                        ...jsonBody,
                        [key]: value,
                      };
                    }
                  });
                  const requestFromQueue = {
                    ...actionToModify,
                    data: {
                      ...actionToModify.data,
                      body: JSON.stringify(jsonBody),
                    },
                  };
                  queue[requestIndex] = {
                    ...requestFromQueue,
                  };

                  newState = {
                    ...newState,
                    queue: [...queue],
                    currentAction: requestFromQueue,
                  };
                  return newState;
                }
              }
            }
          } else if (jsonBodyId) {
            // OFFLINE PUT ( Numeric ID / Autogenerated ID ) search it in queue and merge it (if exist)
            // Add AutogeneratedID to { key: null, value: 'any' } objects
            Object.keys(jsonBody).forEach((key) => {
              const value = jsonBody[key];
              const valueType = Object.prototype.toString.call(value);
              if (valueType === '[object Array]' || Object.prototype.hasOwnProperty.call(value, 'values')) {
                let collectionHasValues; let
                  mappedValue;
                // "contact_" like field
                if (valueType === '[object Array]') {
                  collectionHasValues = (
                    value.length > 0
                    && Object.prototype.toString.call(value[0]) === '[object Object]'
                    // Object.prototype.hasOwnProperty.call(value[0], 'key') &&
                    && Object.prototype.hasOwnProperty.call(value[0], 'value')
                  );
                  mappedValue = value;
                } else if (Object.prototype.hasOwnProperty.call(value, 'values')) {
                  // { key: '', value: '' } array field
                  collectionHasValues = (
                    value.values.length > 0
                    && Object.prototype.toString.call(value.values[0]) === '[object Object]'
                    // Object.prototype.hasOwnProperty.call(value.values[0], 'key') &&
                    && Object.prototype.hasOwnProperty.call(value.values[0], 'value')
                  );
                  mappedValue = value.values;
                }
                if (collectionHasValues) {
                  // Add AutogeneratedID to new objects
                  mappedValue = mappedValue.map((object) => {
                    if (!object.key) {
                      let existingKeyInCollection; let
                        temporalKey;
                      do {
                        // Generate key
                        temporalKey = generateLocalID();
                        // Check if generated key exist in collection
                        /* eslint-disable */
                        existingKeyInCollection = mappedValue.findIndex(objectItem => objectItem.key === temporalKey);
                        /* eslint-enable */
                        // If ID exist, generate another one
                      } while (existingKeyInCollection > -1);
                      return {
                        ...object,
                        key: temporalKey,
                      };
                    }
                    return object;
                  });
                  if (valueType === '[object Array]') {
                    jsonBody = {
                      ...jsonBody,
                      [key]: mappedValue,
                    };
                  } else if (Object.prototype.hasOwnProperty.call(value, 'values')) {
                    jsonBody = {
                      ...jsonBody,
                      [key]: {
                        values: mappedValue,
                      },
                    };
                  }
                }
              } else {
                jsonBody = {
                  ...jsonBody,
                  [key]: value,
                };
              }
            });
            const requestIndex = queue.findIndex((request) => {
              let jsonParseBody;
              if (request.data.body) {
                jsonParseBody = JSON.parse(request.data.body);
              }
              return (actionToModify.url === request.url && actionToModify.action === request.action && jsonParseBody && jsonParseBody.ID === jsonBodyId);
            });
            if (requestIndex > -1) {
              let requestFromQueue = queue[requestIndex];
              const oldRequestBody = JSON.parse(requestFromQueue.data.body);
              let newRequestBody = {
                ...oldRequestBody,
              };
              // MERGE REQUEST BODY CHANGES (MERGE FIELDS OF TYPE COLLECTION AND OTHERS)
              Object.keys(jsonBody).forEach((key) => {
                const value = jsonBody[key];
                const valueType = Object.prototype.toString.call(value);
                if (valueType === '[object Array]' || Object.prototype.hasOwnProperty.call(value, 'values')) {
                  let collection; let
                    oldCollection;
                  if (valueType === '[object Array]') {
                    collection = value;
                    oldCollection = (oldRequestBody[key]) ? [...oldRequestBody[key]] : [];
                  } else if (Object.prototype.hasOwnProperty.call(value, 'values')) {
                    collection = value.values;
                    oldCollection = (oldRequestBody[key]) ? [...oldRequestBody[key].values] : [];
                  }
                  // compare newCollection with old and merge differences.
                  collection.forEach((object) => {
                    // search object in oldRequestBody
                    const findObjectInOldRequestIndex = oldCollection.findIndex(oldObject => (object.key === oldObject.key));
                    if (findObjectInOldRequestIndex > -1) {
                      // if exist
                      if (/^([a-z0-9]{8}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{12})$/.test(object.key)
                        && Object.prototype.hasOwnProperty.call(object, 'delete')
                      ) {
                        // if object have autogenerated id and 'delete' property, remove the object
                        oldCollection.splice(findObjectInOldRequestIndex, 1);
                      } else {
                        // update the object
                        oldCollection[findObjectInOldRequestIndex] = {
                          ...object,
                        };
                      }
                    } else {
                      // add the object
                      oldCollection.push({
                        ...object,
                      });
                    }
                  });
                  if (valueType === '[object Array]') {
                    newRequestBody = {
                      ...newRequestBody,
                      [key]: oldCollection,
                    };
                  } else if (Object.prototype.hasOwnProperty.call(value, 'values')) {
                    newRequestBody = {
                      ...newRequestBody,
                      [key]: {
                        values: oldCollection,
                      },
                    };
                  }
                } else {
                  newRequestBody = {
                    ...newRequestBody,
                    [key]: value,
                  };
                }
              });
              requestFromQueue = {
                ...requestFromQueue,
                data: {
                  ...requestFromQueue.data,
                  body: JSON.stringify(newRequestBody),
                },
              };
              queue[requestIndex] = {
                ...requestFromQueue,
              };
              newState = {
                ...newState,
                queue: [...queue],
                currentAction: requestFromQueue,
              };
              return newState;
            }
          } else {
            // OFFLINE POST (New entity, add autogenerated ID)
            let existingIdInQueue; let
              newID;
            do {
              // Generate ID
              /* eslint-disable */
              newID = generateLocalID();
              // Check if generated ID exist in queue
              existingIdInQueue = queue.findIndex(request => (request.data.method === 'POST' && JSON.parse(request.data.body).ID && JSON.parse(request.data.body).ID === newID));
              /* eslint-enable */
              // If ID exist, generate another one
            } while (existingIdInQueue > -1);
            // if not, use it
            jsonBody = {
              ...jsonBody,
              ID: newID,
            };
            // Add AutogeneratedId to { key: null, value: 'any' } objects
            Object.keys(jsonBody).forEach((key) => {
              const value = jsonBody[key];
              const valueType = Object.prototype.toString.call(value);
              if (valueType === '[object Array]' || Object.prototype.hasOwnProperty.call(value, 'values')) {
                let collectionHasValues; let
                  mappedValue;
                // "contact_" like field
                if (valueType === '[object Array]') {
                  collectionHasValues = (
                    value.length > 0
                    && Object.prototype.toString.call(value[0]) === '[object Object]'
                    // Object.prototype.hasOwnProperty.call(value[0], 'key') &&
                    && Object.prototype.hasOwnProperty.call(value[0], 'value')
                  );
                  mappedValue = value;
                } else if (Object.prototype.hasOwnProperty.call(value, 'values')) {
                  // { key: '', value: '' } array field
                  collectionHasValues = (
                    value.values.length > 0
                    && Object.prototype.toString.call(value.values[0]) === '[object Object]'
                    // Object.prototype.hasOwnProperty.call(value.values[0], 'key') &&
                    && Object.prototype.hasOwnProperty.call(value.values[0], 'value')
                  );
                  mappedValue = value.values;
                }
                if (collectionHasValues) {
                  // Add AutogeneratedID to new objects
                  mappedValue = mappedValue.map((object) => {
                    if (!object.key) {
                      let existingKeyInCollection; let
                        temporalKey;
                      do {
                        // Generate key
                        temporalKey = generateLocalID();
                        // Check if generated key exist in collection
                        /* eslint-disable */
                        existingKeyInCollection = mappedValue.findIndex(objectItem => objectItem.key === temporalKey);
                        /* eslint-enable */
                        // If ID exist, generate another one
                      } while (existingKeyInCollection > -1);
                      return {
                        key: temporalKey,
                        value: object.value,
                      };
                    }
                    return object;
                  });
                  if (valueType === '[object Array]') {
                    jsonBody = {
                      ...jsonBody,
                      [key]: mappedValue,
                    };
                  } else if (Object.prototype.hasOwnProperty.call(value, 'values')) {
                    jsonBody = {
                      ...jsonBody,
                      [key]: {
                        values: mappedValue,
                      },
                    };
                  }
                }
              } else {
                jsonBody = {
                  ...jsonBody,
                  [key]: value,
                };
              }
            });
          }
        }
        actionToModify.data.body = JSON.stringify(jsonBody);
      } else if (actionToModify.data.method === 'GET') {
        // filter out redundant GET requests
        queue = queue.filter(existing => existing.url !== actionToModify.url);
      }
      newState = {
        ...newState,
        queue: [...queue, actionToModify],
        currentAction: actionToModify,
      };
      return newState;
    case actions.RESPONSE:
      // loop through every item in local storage and filter out the successful request
      queue = queue.filter(request => JSON.stringify(request) !== JSON.stringify(action.payload));
      newState = {
        ...newState,
        queue,
      };
      return newState;
    default:
      return newState;
  }
}
